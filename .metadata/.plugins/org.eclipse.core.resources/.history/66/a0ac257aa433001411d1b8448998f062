package org.allenai.extraction.processors.dependencies

import org.allenai.extraction.rdf.{ DependencyGraph, TurtleProcessor }
import org.allenai.extraction.rdf.VertexWrapper.VertexRdf
import com.tinkerpop.blueprints.Vertex
import com.tinkerpop.blueprints.impls.sail.SailGraph
import scala.language.postfixOps
import java.io.IOException

/** processor to match dependency patterns */
object PolyExtractor extends TurtleProcessor {
  // SPARQL queries
  val querysource = io.Source.fromFile("model/disrelsparqlquery.sparql")
  val queries = List() ++ { for (x <- querysource.getLines().toList) yield { (x.split("\t").apply(0), x.split("\t").apply(1)) } }

  val txtsource = io.Source.fromFile("src/test/data/barrons-sentences.txt")
  val indexsentence = (txtsource.getLines().toList.zipWithIndex).toMap.map(_ swap)
  override def processGraph(graph: SailGraph): Unit = {
    for {
      (id, query) <- queries
      map <- DependencyGraph.executeSparql(graph, query)
    } {
      println("using: " + query)
      try {
        
      } catch {
        case e: IOException => e.printStackTrace()
      }
    }
  }
}
